name: Maven Build and Publish to GitHub Packages

on:
  push:
    tags:
      - 'v*.*.*' # Trigger on tags like v1.0.0, v1.2.3, v2.0.0-RC1 etc.

jobs:
  build-and-publish:
    runs-on: ubuntu-latest
    permissions:
      contents: write  # Required for gh CLI (to check releases) and potentially creating releases
      packages: write  # Required to publish packages to GitHub Packages
      # id-token: write # Required if using OIDC for Maven authentication (not strictly needed with GITHUB_TOKEN for GH Packages)

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Required to get full commit history for short SHA

      - name: Get version and short commit hash
        id: get_version
        run: |
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
          # GITHUB_REF_NAME for tag 'v1.2.3' is 'v1.2.3'
          # We remove the 'v' prefix to get '1.2.3'
          BASE_VERSION="${GITHUB_REF_NAME#v}"
          # Construct the full version string in the format: base_version-short_commit_hash
          FULL_VERSION="${BASE_VERSION}-${SHORT_SHA}"

          echo "Base Version (from tag): ${BASE_VERSION}"
          echo "Short SHA: ${SHORT_SHA}"
          echo "Full Artifact Version: ${FULL_VERSION}"

          echo "full_version=${FULL_VERSION}" >> "$GITHUB_OUTPUT"
          echo "base_version=${BASE_VERSION}" >> "$GITHUB_OUTPUT"
          # Since this workflow only triggers on tags, 'is_tag' will always be true
          echo "is_tag=true" >> "$GITHUB_OUTPUT"

      - name: Set up JDK 21 for Maven artifact check
        # This step is needed early to run Maven commands for artifact metadata
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          settings-path: ${{ github.workspace }}
          server-id: github

      - name: Check if artifact with FULL_VERSION already exists in GitHub Packages
        id: check_artifact_exists
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          FULL_VERSION="${{ steps.get_version.outputs.full_version }}"
          echo "Checking for existing artifact version: ${FULL_VERSION} in GitHub Packages..."

          # Temporarily update POM to the full version to get correct artifact coordinates
          # This is a non-destructive way to get the group/artifact ID for the check
          mvn versions:set -DnewVersion="${FULL_VERSION}" -DgenerateBackupPoms=false

          # Extract Group ID and Artifact ID from the POM
          GROUP_ID=$(mvn help:evaluate -Dexpression=project.groupId -q -DforceStdout)
          ARTIFACT_ID=$(mvn help:evaluate -Dexpression=project.artifactId -q -DforceStdout)

          echo "Checking for artifact: ${GROUP_ID}:${ARTIFACT_ID}:${FULL_VERSION}"

          # Use Maven to attempt to resolve the artifact from GitHub Packages.
          # If it resolves successfully, the artifact exists.
          # We use -Dmaven.repo.local to ensure it doesn't use local cache.
          # We use -Dmaven.wagon.http.failOnMissingHeader=false to avoid issues with some proxies/servers.
          # We use -Dmaven.wagon.http.ssl.insecure=true for potentially self-signed certs (use with caution).
          # The -Drepo.url is crucial to point Maven to GitHub Packages.
          # The -s flag points to the settings.xml generated by setup-java for authentication.
          if mvn dependency:get \
            -Dartifact="${GROUP_ID}:${ARTIFACT_ID}:${FULL_VERSION}:pom" \
            -DremoteRepositories="github::default::https://maven.pkg.github.com/${{ github.repository_owner }}" \
            -Dmaven.repo.local="${{ runner.temp }}/.m2_check" \
            -Dmaven.wagon.http.failOnMissingHeader=false \
            -s ${{ github.workspace }}/settings.xml &> /dev/null; then
            echo "Artifact '${GROUP_ID}:${ARTIFACT_ID}:${FULL_VERSION}' already exists in GitHub Packages. Skipping build and publish."
            echo "artifact_exists=true" >> "$GITHUB_OUTPUT"
          else
            echo "Artifact '${GROUP_ID}:${ARTIFACT_ID}:${FULL_VERSION}' does not exist in GitHub Packages. Proceeding with build and publish."
            echo "artifact_exists=false" >> "$GITHUB_OUTPUT"
          fi

          # Revert POM changes (optional, but good practice)
          mvn versions:revert -DgenerateBackupPoms=false || true # '|| true' to prevent failure if no backup pom exists

      - name: Skip message if artifact exists
        # This step runs only if an artifact with the FULL_VERSION was found
        if: steps.check_artifact_exists.outputs.artifact_exists == 'true'
        run: |
          echo "::notice::Skipping build and publish as artifact '${{ steps.get_version.outputs.full_version }}' already exists in GitHub Packages."
          exit 0 # Exit the job early, effectively skipping all subsequent steps

      # --- All subsequent steps will only run if the artifact does NOT exist ---

      # Re-setup JDK if needed, as the previous setup might have been for a temporary check
      # This step is technically redundant if the previous setup-java was sufficient,
      # but it ensures a clean setup for the actual build.
      - name: Set up JDK 21 for actual build
        if: steps.check_artifact_exists.outputs.artifact_exists != 'true'
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          settings-path: ${{ github.workspace }}
          server-id: github

      - name: Update POM version to full artifact version
        # This step ensures the pom.xml's <version> matches the new format (e.g., 1.3.0-abcdefg)
        if: steps.check_artifact_exists.outputs.artifact_exists != 'true'
        run: mvn versions:set -DnewVersion=${{ steps.get_version.outputs.full_version }} -DgenerateBackupPoms=false

      - name: Build with Maven
        # Runs tests and builds the artifact
        if: steps.check_artifact_exists.outputs.artifact_exists != 'true'
        run: mvn clean install -B # -B for batch mode (non-interactive)

      - name: Publish to GitHub Packages
        # The -s flag points to the settings.xml generated by setup-java
        # This settings.xml contains the necessary authentication for GitHub Packages.
        if: steps.check_artifact_exists.outputs.artifact_exists != 'true'
        run: mvn deploy -s ${{ github.workspace }}/settings.xml
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create GitHub Release (Optional)
        # This step creates a formal GitHub Release entry for the base tag.
        # It runs only if the artifact was successfully built and published.
        # Note: If you force-push a tag to a new commit, and a GitHub Release
        # for that base tag already exists, this step will fail.
        # Consider if you truly need a GitHub Release for every unique full_version,
        # or if the GitHub Packages artifact is sufficient.
        if: steps.check_artifact_exists.outputs.artifact_exists != 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.get_version.outputs.base_version }} # Use the base tag name (e.g., '1.2.3') for the release
          name: Release ${{ steps.get_version.outputs.base_version }}
          body: |
            Automated release for tag `${{ github.ref_name }}`.
            Full artifact version: `${{ steps.get_version.outputs.full_version }}`
            Commit SHA: `${{ github.sha }}`
          draft: false
          prerelease: false
          # You can attach your build artifacts (e.g., JARs) to the GitHub Release here:
          # files: target/*.jar # Uncomment and adjust if you want to attach the JAR to the GitHub Release
